# Auditoria de Seguretat — 2026-01-04

## Resum Executiu

| Àrea | Estat | Risc Residual |
|------|-------|---------------|
| Storage cross-org | **PASS** | Baix (pendent smoke test) |
| Members self-join | **PASS** | Baix |
| Invitations escalada | **PASS** | Baix |
| Invitació usuari existent | **PASS** | Baix |
| Transactions validation | **PASS** | Baix (Fase 1 aplicada) |
| Imports idempotència | **PASS** | Baix (chunking 450 implementat) |
| Exports | **PASS** | Baix |
| SuperAdmin provider | **PASS** | Baix |

---

## 1. Storage Rules — P0 Fix

### Vulnerabilitat Original (P0 crític)

```javascript
// ABANS: Qualsevol usuari autenticat podia accedir a QUALSEVOL org
match /organizations/{orgId}/{allPaths=**} {
  allow read, write: if isSignedIn();  // ← Cross-org access
}
```

### Regla Corregida

```javascript
// DESPRÉS: Només membres de l'org o SuperAdmin
match /organizations/{orgId}/{allPaths=**} {
  allow read, write: if isSuperAdmin() || isOrgMember(orgId);
}
```

### Desplegament

```
$ firebase use
summa-social

$ firebase deploy --only storage
=== Deploying to 'summa-social'...
✔  firebase.storage: rules file storage.rules compiled successfully
✔  storage: released rules storage.rules to firebase.storage
✔  Deploy complete!
```

### Smoke Tests — Evidència Cross-Org

> **IMPORTANT:** Completar aquests tests manualment i anotar data/hora + codi error.
> Sense evidència, l'auditoria queda oberta.

| # | Usuari | Acció | Esperat | Resultat | Data/Hora |
|---|--------|-------|---------|----------|-----------|
| 1 | UserA (OrgA) | Llegir fitxer OrgB | DENY/403 | _pendent_ | - |
| 2 | UserA (OrgA) | Pujar a OrgB | DENY/403 | _pendent_ | - |
| 3 | UserB (OrgB) | Llegir/pujar a OrgB | ALLOW | _pendent_ | - |
| 4 | SuperAdmin | Llegir/pujar qualsevol org | ALLOW | _pendent_ | - |

**Instruccions per executar:**
1. Obrir consola del navegador (F12 → Console)
2. Login com UserA (membre només de OrgA)
3. Intentar `getDownloadURL(ref(storage, 'organizations/OrgB/test.pdf'))` → esperar error 403
4. Repetir amb upload
5. Canviar a UserB i SuperAdmin per verificar ALLOW

---

## 2. Firestore Rules — Members/Invitations

### 2.1 Members Self-Join — P0 Fix

**Vulnerabilitat Original:**
```javascript
// Permetia que qualsevol usuari autenticat es fes membre de qualsevol org
allow create: if isSignedIn() && request.auth.uid == memberId;
```

**Regla Corregida:**
```javascript
allow create: if isAdminOf(orgId) || isSuperAdmin()
  || (isSignedIn()
      && request.auth.uid == memberId
      // Invitació ha d'existir
      && exists(/databases/$(database)/documents/invitations/$(request.resource.data.invitationId))
      // orgId ha de coincidir
      && get(...).data.organizationId == orgId
      // email ha de coincidir
      && get(...).data.email == request.auth.token.email
      // Invitació no usada
      && get(...).data.usedAt == null
      // ROL DERIVAT: el rol del membre HA de ser el de la invitació
      && request.resource.data.role == get(...).data.role
      // Camps permesos (actualitzat per incloure camps legacy del client)
      && request.resource.data.keys().hasOnly(['role', 'invitationId', 'email', 'displayName', 'photoURL', 'userId', 'joinedAt']));
```

**Client Fix (registre/page.tsx):**
- Afegit `invitationId` al `memberData` per complir amb la regla de Firestore

**Mitigacions:**
- ✅ Self-join eliminat sense invitació vàlida
- ✅ Rol forçat de la invitació (client no pot triar)
- ✅ Camps restringits via `keys().hasOnly()`

### 2.2 Invitations Escalada — P0/P1 Fix

**Vulnerabilitat Original:**
```javascript
// Qualsevol podia llegir invitacions (exposició d'emails)
allow read: if isSignedIn();
// Update sense restriccions d'immutabilitat
allow update: if isSignedIn() && resource.data.email == request.auth.token.email;
```

**Regla Corregida (read):**
```javascript
allow read: if isSuperAdmin()
  || (isSignedIn() && resource.data.createdBy == request.auth.uid)
  || (isSignedIn() && isAdminOf(resource.data.organizationId))
  || (isSignedIn() && resource.data.email == request.auth.token.email);
```

**Regla Corregida (update - acceptació):**
```javascript
allow update: if isSuperAdmin()
  || (isSignedIn() && resource.data.createdBy == request.auth.uid)
  || (isSignedIn() && isAdminOf(resource.data.organizationId))
  // Acceptació d'invitació
  || (isSignedIn()
      && resource.data.email == request.auth.token.email
      && resource.data.usedAt == null
      && request.resource.data.usedAt != null
      && request.resource.data.usedBy == request.auth.uid
      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['usedAt', 'usedBy'])
      // IMMUTABILITAT
      && request.resource.data.organizationId == resource.data.organizationId
      && request.resource.data.email == resource.data.email
      && request.resource.data.role == resource.data.role
      && request.resource.data.createdBy == resource.data.createdBy);
```

**Mitigacions:**
- ✅ Read restringit a creador/admin/destinatari
- ✅ `usedBy == request.auth.uid` (qui accepta és qui s'autentica)
- ✅ Immutabilitat explícita de camps crítics
- ✅ `affectedKeys().hasOnly()` per restringir modificacions

### 2.3 SystemIncidents — P1 Fix

**Vulnerabilitat Original:**
```javascript
allow update: if isSignedIn();  // DoS/spam via updates
```

**Regla Corregida:**
```javascript
allow create: if isSignedIn();  // Reportar errors
allow update: if isSuperAdmin();  // Només admin pot modificar
```

---

## 3. Risc Residual TOCTOU

**Escenari:** Race condition entre check de `usedAt == null` i write.

**Mitigació actual:**
- L'acceptació (update invitation) i create member són operacions separades
- El create member valida `invitation.usedAt == null`
- Si dos requests arriben simultàniament, només un guanya el lock de Firestore

**Millora futura (opcional):**
- Usar transacció atòmica per acceptar + crear membre
- O validar `invitation.usedBy == request.auth.uid` en el create member

---

## 4. Auditoria P1 — Transactions, Imports, Exports

### 4.1 Transactions Validation — ✅ FIX APLICAT

**Risc:** Un "user" pot injectar dades que trenquin saldos, exports o models fiscals.

**Regla aplicada (Fase 1 - mínima):**
```javascript
match /transactions/{transactionId} {
  allow create: if ...
    // Camps obligatoris existeixen
    && request.resource.data.keys().hasAll(['amount', 'date', 'description'])
    // amount ha de ser número
    && request.resource.data.amount is number;

  allow update: if ...
    // Si s'actualitza amount, ha de ser number
    && (!('amount' in request.resource.data) || request.resource.data.amount is number);
}
```

**Estat:** ✅ Desplegat `firebase deploy --only firestore:rules`

**Millores futures (Fase 2):**
- Afegir validació d'enums (`transactionType in [...]`)
- Afegir `amount != 0` (opcional segons casos d'ús)
- Restringir camps amb `keys().hasOnly()`

### 4.2 Imports Idempotència — ✅ IMPLEMENTAT

**Risc:** Tall de xarxa durant import deixa duplicats o saldo divergent.

**Anàlisi de `transaction-importer.tsx`:**

| Aspecte | Estat | Detall |
|---------|-------|--------|
| Dedup key | ✅ | `date\|description\|amount` (línia 63-66) |
| Detecció duplicats | ✅ | Compara amb `existingTransactionKeys` |
| writeBatch | ✅ | Usa `writeBatch(firestore)` |
| Segmentació 450 | ✅ | **IMPLEMENTAT** - Chunks de màxim 450 operacions |

**Implementació (commit pendent):**

```typescript
const BATCH_LIMIT = 450; // Marge de seguretat sota el límit de 500

function chunk<T>(arr: T[], size: number): T[][] {
  const out: T[][] = [];
  for (let i = 0; i < arr.length; i += size) {
    out.push(arr.slice(i, i + size));
  }
  return out;
}

// Processar deletes i creates en chunks separats
const deleteChunks = chunk(deleteOperations, BATCH_LIMIT);
const createChunks = chunk(createOperations, BATCH_LIMIT);

for (const deleteChunk of deleteChunks) {
  const batch = writeBatch(firestore);
  deleteChunk.forEach(txId => batch.delete(doc(ref, txId)));
  await batch.commit();
}

for (const createChunk of createChunks) {
  const batch = writeBatch(firestore);
  createChunk.forEach(op => batch.set(op.ref, op.data));
  await batch.commit();
}
```

**Guardrails:**
- ✅ Límit 450 operacions per batch (sota el màxim de 500)
- ✅ Progress log: "Lot X/Y: N transaccions creades/eliminades"
- ✅ Error handling: Si falla a mig camí, mostra missatge clar sense reintentar
- ✅ Deletes primer, creates després (evita inconsistències en mode replace)

**Fitxer modificat:**
- `src/components/transaction-importer.tsx`

**Risc residual:** Baix. Si falla a mig camí, l'usuari rep instruccions clares.

### 4.3 Exports — ✅ VERIFICAT SEGUR

**Risc:** Filtracions via exports mal protegits.

**Regles actuals:**
```javascript
match /exports/{exportType} {
  allow read: if isMemberOf(orgId) || hasOrgInProfile(orgId) || isSuperAdmin();
  allow write: if false;  // ✅ Bloquejat

  match /items/{itemId} {
    allow read: if isMemberOf(orgId) || hasOrgInProfile(orgId) || isSuperAdmin();
    allow create, update, delete: if false;  // ✅ Bloquejat
  }
}
```

**Estat:** ✅ Correcte - Client no pot escriure exports

---

## 5. Flux Invitació Usuari Existent — ✅ FIX APLICAT

**Escenari:** Usuari amb compte existent rep invitació a nova organització.

**Flux anterior (trencat):**
1. Usuari intenta registrar-se → `auth/email-already-in-use` → error genèric
2. Usuari havia de fer login manualment i perdre el context de la invitació

**Flux corregit:**
1. Usuari intenta registrar-se → `auth/email-already-in-use`
2. Sistema redirigeix automàticament a `/{slug}/login?inviteToken=...`
3. Usuari fa login amb compte existent
4. Sistema valida invitació:
   - `organizationId` correcte
   - `usedAt == null`
   - `email` coincideix (si especificat)
   - `expiresAt > now()`
5. Si vàlid: create member + update invitation
6. Missatges d'error clars per cada cas de fallida

**Fitxers modificats:**
- `src/app/registre/page.tsx` — redirecció automàtica
- `src/app/[orgSlug]/login/page.tsx` — validacions + `invitationId` al memberData

**Guardrails de seguretat:**
- ✅ Rol forçat de la invitació (client no pot triar)
- ✅ `invitationId` obligatori (requerit per Firestore Rules)
- ✅ Validació email coincideix
- ✅ Validació expiració

**Commit:** `3f81589`

---

## 6. SuperAdmin Provider — ✅ FIX DEFINITIU (Canary Read)

**Escenari:** SuperAdmin rep intermitentment "No tens accés a aquesta organització".

**Causa arrel:**
- El client decidia permisos localment (comprovant members, systemSuperAdmins)
- Això causava falsos negatius quan les comprovacions fallaven per timing

**Solució definitiva (Canary Read Pattern):**

El client **NO** decideix permisos. Les Firestore Rules són l'única autoritat.

```typescript
// CANARY READ: Si getDoc(org) passa, l'usuari té accés
const orgRef = doc(firestore, 'organizations', orgId);
try {
  orgSnap = await getDoc(orgRef);
} catch (readErr) {
  if (isPermissionDenied(readErr)) {
    throw new AccessDeniedError(); // Només si Firestore diu DENY
  }
  throw readErr; // Altres errors: network, etc.
}
```

**Canvis clau:**
1. Eliminada lògica client-side de decisió de permisos
2. `AccessDeniedError` només es llança si Firestore retorna `permission-denied`
3. El rol de l'usuari es carrega per UI, no per decidir accés
4. Eliminat retry (no necessari amb canary read)

**Fitxer modificat:**
- `src/hooks/organization-provider.tsx`

**Guardrails:**
- ✅ El client NO decideix permisos
- ✅ Firestore Rules = single source of truth
- ✅ "No tens accés" només si Firestore retorna permission-denied
- ✅ Errors de xarxa mostren "Error tècnic", no "No tens accés"

**Commits:**
- `40c6bc0` — Primer intent (systemSuperAdmins + retry)
- `a9951af` — Fix definitiu (canary read pattern)

---

## 7. Historial de Canvis

| Data | Canvi | Estat |
|------|-------|-------|
| 2026-01-04 | Storage P0 fix (cross-org) | ✅ Desplegat |
| 2026-01-04 | Members P0 fix (self-join + invitationId) | ✅ Desplegat |
| 2026-01-04 | Invitations P0/P1 fix (escalada + immutabilitat) | ✅ Desplegat |
| 2026-01-04 | SystemIncidents P1 fix (update restrict) | ✅ Desplegat |
| 2026-01-04 | Transactions validation (Fase 1) | ✅ Desplegat |
| 2026-01-04 | Client fix: invitationId a registre | ✅ Aplicat |
| 2026-01-04 | Exports verificació | ✅ Segur |
| 2026-01-04 | Imports segmentació 500 | ⚠️ Pendent |
| 2026-01-04 | Flux invitació usuari existent (login + accept) | ✅ Desplegat |
| 2026-01-04 | SuperAdmin provider: canary read pattern | ✅ Desplegat |
| 2026-01-04 | Client fix: query invitations només si admin | ✅ Aplicat |
| 2026-01-04 | Firestore listeners logout guard (auth=null) | ✅ Aplicat |
| 2026-01-04 | AuthRedirectGuard: redirect immediat a logout | ✅ Aplicat |

---

## 7b. Client Fix — Query Invitations (P0 UX)

**Problema:** Després del fix de canary read, el client seguia fent `list` sobre `/invitations` que fallava amb `permission-denied` per a usuaris no-admin.

**Causa:** `useCollection` amb `where('organizationId', '==', orgId)` segueix sent un `list` que Firestore avalua ABANS d'aplicar el filtre. Les rules d'invitations requereixen que l'usuari sigui admin de l'org.

**Fix:** Només fer la query si `userRole === 'admin'`:

```typescript
const invitationsQuery = useMemoFirebase(
  () => (organizationId && userRole === 'admin') ? query(
    collection(firestore, 'invitations'),
    where('organizationId', '==', organizationId)
  ) : null,
  [firestore, organizationId, userRole]
);
```

**Fitxers modificats:**
- `src/components/members-manager.tsx`
- `src/components/member-inviter-importer.tsx`

**Guardrails:**
- ✅ Usuaris no-admin no veuen error de permisos
- ✅ UI d'invitacions només es mostra si `isAdmin` (ja era així)
- ✅ No hi ha query innecessària si l'usuari no pot veure les dades

---

## 7c. Client Fix — Firestore Listeners Logout Guard (P0 UX)

**Problema:** Després de logout, els listeners de Firestore (onSnapshot) seguien actius breument, causant errors `permission-denied` amb `auth: null`.

**Causa:**
1. Quan l'usuari fa logout, `user` passa a `null` al `FirebaseProvider`
2. L'`OrganizationProvider` detecta `!user` i fa `router.replace('/login')`
3. Abans que el router completi, els components fills encara estan muntats amb listeners actius
4. Els listeners fallen amb `permission-denied` (ja no hi ha autenticació)
5. L'`errorEmitter` emetia l'error i `FirebaseErrorListener` el llançava

**Fix aplicat:**

1. **useCollection / useDoc** — No emetre error global si `auth === null`:
```typescript
// Dins del error callback de onSnapshot:
if (contextualError.request.auth === null) {
  console.log('[useCollection] Ignoring permission error (user not authenticated):', path);
  return;  // No emetre a errorEmitter
}
errorEmitter.emit('permission-error', contextualError);
```

2. **useBankAccounts** — Guard sobre `user`:
```typescript
useEffect(() => {
  if (!user || !organizationId || !firestore) {
    setAllBankAccounts([]);
    setIsLoading(false);
    setError(null);
    return;
  }
  // ... crear listener
}, [firestore, organizationId, user]);
```

3. **useInitializeOrganizationData** — Guard sobre `user`:
```typescript
useEffect(() => {
  if (!user) return;
  // ... queries
}, [user, organizationId, ...]);
```

4. **FirebaseErrorListener** — Ignorar errors si no hi ha usuari:
```typescript
if (error && !firebaseContext?.user) {
  // No llançar l'error - ignorar durant logout
  return null;
}
```

**Fitxers modificats:**
- `src/firebase/firestore/use-collection.tsx`
- `src/firebase/firestore/use-doc.tsx`
- `src/hooks/use-bank-accounts.ts`
- `src/hooks/use-initialize-user-data.ts`
- `src/components/FirebaseErrorListener.tsx`

**Guardrails:**
- ✅ Errors `permission-denied` amb `auth: null` s'ignoren (esperables durant logout)
- ✅ Listeners es desmunten quan `user` passa a `null`
- ✅ No hi ha spam d'incidents a `systemIncidents`
- ✅ L'usuari veu el redirect a login, no la pàgina d'error

---

## 7d. Logout Determinista — Hard Redirect (P0 UX)

**Problema:** Després del fix de ignorar errors amb `auth: null`, l'usuari es quedava a `/dashboard` amb dades buides en lloc de ser redirigit a login. El `router.replace()` era massa "suau" i permetia que la UI es quedés visible durant la transició.

**Causa:**
1. L'`OrganizationProvider` ja tenia un redirect quan `!user`, però no era prou ràpid
2. `router.replace()` de Next.js és asíncron i no desmunta l'app immediatament
3. Durant la transició, els components es renderitzaven amb dades buides ("dashboard a 0")

**Solució final (doble cinturó):**

### 1. AuthRedirectGuard amb hard redirect

Component al `FirebaseProvider` que detecta la transició logged-in → logged-out i fa `window.location.assign()` (hard redirect) per desmuntar tota l'app immediatament:

```typescript
// src/components/AuthRedirectGuard.tsx
export function AuthRedirectGuard() {
  const firebaseContext = useContext(FirebaseContext);
  const pathname = usePathname();
  const hasRedirectedRef = useRef(false);
  const wasLoggedInRef = useRef<boolean | null>(null);

  useEffect(() => {
    if (firebaseContext?.isUserLoading) return;

    const isLoggedIn = !!firebaseContext?.user;
    const wasLoggedIn = wasLoggedInRef.current;
    wasLoggedInRef.current = isLoggedIn;

    // Transició: de logged in a logged out
    if (wasLoggedIn === true && !isLoggedIn) {
      if (hasRedirectedRef.current) return;
      if (pathname.includes('/login') || isPublicPath(pathname)) return;

      const orgSlug = extractOrgSlugFromPath(pathname);
      hasRedirectedRef.current = true;

      // HARD REDIRECT: Desmunta tota l'app immediatament
      if (orgSlug) {
        window.location.assign(`/${orgSlug}/login`);
      } else {
        window.location.assign('/');
      }
    }

    if (isLoggedIn) hasRedirectedRef.current = false;
  }, [firebaseContext?.user, firebaseContext?.isUserLoading, pathname]);

  return null;
}
```

### 2. Backup al botó de logout

L'`OrganizationProvider.handleLogout()` també fa hard redirect com a backup:

```typescript
const handleLogout = async () => {
  const loginUrl = orgSlug ? `/${orgSlug}/login` : '/';
  try {
    await signOut(auth);
  } catch (err) {
    console.error('[ORG_PROVIDER] Error signing out:', err);
  }
  // Hard redirect sempre, fins i tot si signOut falla
  window.location.assign(loginUrl);
};
```

**Fitxers modificats:**
- `src/components/AuthRedirectGuard.tsx` (nou)
- `src/firebase/provider.tsx` (afegit `<AuthRedirectGuard />`)
- `src/hooks/organization-provider.tsx` (hard redirect a `handleLogout`)

**Commits:**
- `0e99c23` — fix(auth): stop firestore listeners on logout
- `e54050f` — feat(auth): add AuthRedirectGuard for immediate logout redirect
- `a1cc188` — fix(auth): hard redirect to org login on logout to avoid stale dashboard
- `05030d9` — fix(auth): hard redirect on logout button (backup for guard)

**Guardrails:**
- ✅ Hard redirect desmunta l'app immediatament (no "dashboard a 0")
- ✅ Conserva el context d'org (redirigeix a `/{orgSlug}/login`, no a `/`)
- ✅ No redirigeix si ja estem a login o path públic
- ✅ Detecta correctament la transició (no redirigeix al primer mount)
- ✅ Doble cinturó: guard + backup al botó de logout

**Proves de validació:**

| Org | Flux | Esperat | Resultat |
|-----|------|---------|----------|
| Flores | login → dashboard → logout | Redirect immediat a `/flores/login` sense "dashboard buit" | _pendent_ |
| Baruma | login → dashboard → logout | Redirect immediat a `/baruma/login` sense "dashboard buit" | _pendent_ |

---

## 8. Signatura

- **Auditor:** Claude Code (automatitzat)
- **Revisat per:** _pendent revisió manual_
- **Data:** 2026-01-04
